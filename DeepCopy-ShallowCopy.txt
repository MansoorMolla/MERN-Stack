When working with objects in JavaScript, we sometimes need to copy them. However, copying can be done in two ways:

Shallow Copy (Copies only the first level of properties, nested objects remain shared)
Deep Copy (Creates a completely independent copy, including nested objects)



What is a Shallow Copy?
A shallow copy creates a new object and copies only the top-level properties. However, nested objects (references) are not duplicated; instead, their reference is copied. This means that if the nested object is modified in the copy, the original object will also be affected.

const original = {
  name: "Mansoor",
  details: {
    age: 25,
    city: "Hyderabad"
  }
};

// Creating a shallow copy
const shallowCopy = { ...original };

// Modifying a nested object in shallow copy
shallowCopy.details.city = "Bangalore";

console.log(original.details.city); // ‚ö†Ô∏è Output: "Bangalore" (Original is affected)
console.log(shallowCopy.details.city); // "Bangalore"

Since details is an object, both the original and copy share the same reference.
Any changes to shallowCopy.details will modify original.details as well.


However, if you modify a direct (non-nested) property, the original object is not affected:
shallowCopy.name = "Ahmed";
console.log(original.name); // ‚úÖ Output: "Mansoor" (Original is NOT affected)
console.log(shallowCopy.name); // "Ahmed"
Reason: Primitive values (like strings, numbers) are copied by value, not by reference.


What is a Deep Copy?
A deep copy creates a completely independent copy of the object, including nested objects. This means that changes to the copied object will not affect the original object.

üîπ Example of Deep Copy using structuredClone():

javascript
Copy
Edit
const original = {
  name: "Mansoor",
  details: {
    age: 25,
    city: "Hyderabad"
  }
};

// Creating a deep copy
const deepCopy = structuredClone(original);

// Modifying a nested object in deep copy
deepCopy.details.city = "Bangalore";

console.log(original.details.city); // ‚úÖ Output: "Hyderabad" (Original is NOT affected)
console.log(deepCopy.details.city); // "Bangalore"
‚úÖ Conclusion:

Both top-level and nested objects are fully copied.
Any modification to deepCopy.details does not affect original.details.


Methods to Create Shallow Copy
const shallowCopy = { ...original };
const shallowCopy = Object.assign({}, original);


Methods to Create Deep Copy
const deepCopy = structuredClone(original);
const deepCopy = JSON.parse(JSON.stringify(original));







In JavaScript, a **shallow copy** of an object is a new object that has the same properties as the original, but the properties that are objects themselves are shared between the original and the copy. This means that if you modify a nested object in the copy, it will also change in the original object.

Here's an example of a shallow copy using the assignment operator:

```javascript
let original = { a: 1, b: { c: 2 } };
let copy = original; // Shallow copy
copy.a = 3;
copy.b.c = 4;

console.log(original); // { a: 1, b: { c: 4 } }
console.log(copy); // { a: 1, b: { c: 4 } }
```

As you can see, changing `copy.b.c` also changes `original.b.c` because the `b` object is shared.

A **deep copy**, on the other hand, creates a new object and recursively copies all properties of the original, including nested objects. This means that the copy is completely independent of the original.

Here's how you can create a deep copy in JavaScript:

```javascript
let original = { a: 1, b: { c: 2 } };
let copy = JSON.parse(JSON.stringify(original)); // Deep copy
copy.a = 3;
copy.b.c = 4;

console.log(original); // { a: 1, b: { c: 2 } }
console.log(copy); // { a: 3, b: { c: 4 } }
```

In this case, `original` remains unchanged when we modify `copy`.

It's important to note that `JSON.parse(JSON.stringify())` has limitations. It does not copy functions or handle circular references, and it does not preserve special object types like `Date`, `RegExp`, or custom classes. For more complex cases, libraries like Lodash provide a `cloneDeep` function that can handle such scenarios¬π.

A shallow copy creates a new object with the same reference as the original object, while a deep copy creates a new object with a new reference.



